#include<iostream>
#include<vector>

using namespace std;
typedef long long ll;
#define int ll
/* 
Cистема непересекающихся множеств
Изначально имеется n элементов, каждый из которых находится в своём собственном множестве. 
Структура поддерживает две базовые операции:
- Объединить два множества.
- Узнать, в каком множестве находится указанный элемент.
Обе операции выполняются почти за O(1)
Множества элементов храним в виде деревьев: одно дерево соответствует одному множеству. 
Корень дерева — это "лидер" множества. Для корней будем считать, что их лидеры — они сами.
Также будем хранить для каждой вершины её ранг — высоту её поддерева.
*/
struct Dsu {
	vector<int> l; // лидеры
	vector<int> r; // ранги деревьев
	void init(int n) {
		l.resize(n);
		r.resize(n, 1); // изначально высота каждого дерева 1
		for (int i = 0; i < n; ++i) {
			l[i] = i;
		}
	}
	/* 
 	Для запроса "в каком множестве элемент v" нужно подняться по ссылкам до лидера. 
	Но перед тем, как вернуть ответ, запишем его в l[v] (переподвесим v за самого высокого), 
	чтобы сразу указывать на лидера, минуя промежуточные узлы.
	*/
	int leader(int v) {
		if (l[v] == v) {
			return v;
		}
		return l[v] = leader(l[v]);
	}
	/* 
 	Для объединения множеств, содержащих a и b:
	Cначала находятся лидеры обоих множеств. Если оба элемента принадлежат одному и тому же 
	множеству (их лидеры совпадают), то объединение не происходит. Если множества разные, 
	выбирается тот лидер, чей ранг меньше, и меньшее дерево присоединяется к большему. Это 
	делается для минимизации высоты итогового дерева и оптимизации поиска лидеров. После объединения 
	обновляется ранг нового лидера и устанавливается новый лидер для всех элементов 
	младшего дерева.
	При объединении двух деревьев с одинаковыми рангами происходит увеличение ранга на 1 у нового корня:
	   A        B
	  / \      / \
	 1   2    4   5
		   ...
	        A
          / | \
         1  2  B
              / \
             4   5
	*/
	bool unite(int a, int b) {
		a = leader(a); b = leader(b);
		if (a == b) {
			return false;
		}
		if (r[a] > r[b]) {
			swap(a, b);
		}
		r[b] = max(r[b], r[a] + 1);
		l[a] = b;
		return true;
	}
};
signed main() {
	return 0;
}
