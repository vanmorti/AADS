#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
#define int ll

/*
1. Введение
Полиномиальное хеширование — это техника, используемая для эффективного сравнения строк и подстрок,
а также для решения других задач обработки строк, таких как поиск палиндромов, подсчёт количества 
различных подстрок и т. д.
Основная идея: представить строку в виде числа (хеша), вычисленного по определённым правилам, чтобы 
сравнивать строки за O(1).

2. Определение полиномиального хеша
Пусть дана строка S​, где каждый символ s[i] имеет числовой код (например, ASCII или просто номер в 
алфавите). Тогда полиномиальный хеш строки S определяется как:

H(S) = (s[0] * p^(n − 1) + s[1] * p^(n − 2) + ... + s[n − 2] * p + s[n − 1]) %  m
 
где: p — основание хеширования (обычно простое число, большее размера алфавита),
m — модуль (большое число, часто 2^64 или простое число порядка 10^9).

3. Свойства полиномиального хеша
Устранение коллизий:
При правильном выборе p и m вероятность коллизий (разные строки имеют одинаковый хеш) мала.
Вычисление за линейное время:
Хеш всей строки можно вычислить за
O(n) с помощью префиксных хешей.
Быстрое вычисление хеша любой подстроки:
Если предподсчитать префиксные хеши и степени p, то хеш любой подстроки S[l..r] можно вычислить за 
O(1).

4. Префиксные хеши
Для быстрого вычисления хешей подстрок массив префиксных хешей
h и массив степеней числа p (pow) вычисляются так:

h[0] = 0, h[i + 1] = (h[i] * p + s[i]) %  m

pow[0] = 1, pow[i] = (pow[i − 1] * p) %  m

Тогда хеш подстроки
S[l..r] вычисляется как:

H(S[l..r]) = (h[r + 1] − h[l] * pow[r − l + 1]) %  m
*/

const ll BASE = 911382629;     // Простое основание
const ll MOD = 1e18 + 3;       // Большой модуль (можно взять 1e9 + 9)


vector<ll> comp_pows(int max_pow) { // max_pow - не меньше максимально возможной длины строки
    vector<ll> pow(max_pow + 1);
    pow[0] = 1;
    for (int i = 1; i <= max_pow; ++i) {
        pow[i] = (pow[i - 1] * BASE) % MOD;
    }
    return pow;
}

vector<ll> comp_pref_hash(const string& s) {
    int n = s.size();
    vector<ll> hash(n + 1, 0);
    for (int i = 0; i < n; ++i) {
        hash[i + 1] = (hash[i] * BASE + s[i]) % MOD;
    }
    return hash;
}


ll get_substr_hash(const vector<ll>& hash, const vector<ll>& pow, int l, int r) {
    int len = r - l + 1;
    ll res = (hash[r + 1] - hash[l] * pow[len] % MOD + MOD) % MOD;
    return res;
}

signed main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);

    string s = "abacaba";
    int n = s.size();

    auto pow = comp_pows(n);
    auto hash = comp_pref_hash(s);

    // Пример: хэш подстроки "bac" (индексы 1..3)
    ll h = get_substr_hash(hash, pow, 1, 3);
    cout << "Hash of 'bac': " << h << endl;

    return 0;
}
