#include <iostream>
#include <vector>
#include <set>
using namespace std;
/*
Алгоритм Прима —  алгоритм поиска минимального остовного дерева (MST) в графе. Минимальное остовное дерево — это такое 
подмножество рёбер графа, которое соединяет все вершины графа с минимальной суммарной стоимостью рёбер.
Основная идея: 
Алгоритм Прима постепенно строит минимальное остовное дерево, начиная с произвольной вершины и добавляя на каждом шаге 
ребро наименьшего веса, которое связывает уже построенную часть дерева с ещё не включёнными вершинами.
Шаги алгоритма:
1. Начало:
Выбираем любую вершину графа в качестве начальной точки.
Добавляем её в множество вершин, входящих в текущее остовное дерево.
Все остальные вершины пока остаются вне множества.
2. Основной цикл:
На каждом шаге выбираем ребро с минимальным весом среди всех рёбер, которые связывают вершину из текущего остовного дерева с вершиной, ещё не входящей в него.
Добавляем выбранное ребро и соответствующую вершину в остовное дерево.
Повторяем шаг 2 до тех пор, пока все вершины не будут включены в остовное дерево.
*/
int main() {
    int n, m;
    cin >> n >> m;
    vector<vector<pair<int, int>>> g(n); // Список смежности для хранения рёбер
    for (int i = 0; i < m; ++i) {
        int from, to, weight;
        cin >> from >> to >> weight;
        from--; to--;

        g[from].push_back({weight, to});
        g[to].push_back({weight, from});
    }
    vector<bool> in(n); // Массив для отслеживания вершин в минимальном остове
    set<pair<int, int>> q; // Множество для хранения рёбер в порядке возрастания веса
    // Начинаем с первой вершины
    in[0] = true;
    for (auto edge : g[0]) { // Добавляем все рёбра, исходящие из первой вершины
        q.insert(edge);
    }
    int ans = 0;
    while (!q.empty()) {
        auto [w, v] = *q.begin(); // Получаем ребро с минимальным весом
        q.erase(q.begin());
        // Проверяем, находится ли вторая вершина ребра вне MST
        if (!in[v]) {
            ans += w;
            in[v] = true; // Добавляем вторую вершину ребра в MST
            // Добавляем все рёбра, исходящие из новой вершины в MST
            for (auto [weight, to] : g[v]) {
                if (!in[to]) {
                    q.insert({weight, to});
                }
            }
        }
    }
    cout << ans << endl;
    return 0;
}
